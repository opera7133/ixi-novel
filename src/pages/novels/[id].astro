---
import { getCollection, render } from "astro:content";
import Layout from "../../layouts/Layout.astro";
import { getTranslations } from "../../utils/i18n";

export async function getStaticPaths() {
  const novels = await getCollection("novels");
  return novels.map((novel) => ({
    params: { id: String(novel.data.id) },
    props: { novel },
  }));
}

function calculateStats(body?: string) {
  if (!body) {
    return { characterCount: 0, readingTime: 0 };
  }
  // "# 本文" から最後までの内容を抽出（次の # があればそこまで）
  const mainTextMatch = body.match(/^# 本文\n([\s\S]*)$/m);

  if (!mainTextMatch) {
    return { characterCount: 0, readingTime: 0 };
  }

  let mainText = mainTextMatch[1];

  // 次の "# " で始まるセクションがあれば、そこまで抽出
  const nextSectionMatch = mainText.match(/^([\s\S]*?)\n^# /m);
  if (nextSectionMatch) {
    mainText = nextSectionMatch[1];
  }

  // 見出しを除外（行頭の # で始まる行）
  const withoutHeadings = mainText
    .split("\n")
    .filter((line) => !line.trim().startsWith("#"))
    .join("\n");

  // 全ての改行、スペースを除いた文字数を計算
  const characterCount = withoutHeadings.replace(/\n|\s/g, "").length;

  // 読み終わるまでの時間を計算（1分間に400文字が目安）
  const readingTime = Math.ceil(characterCount / 500);

  return { characterCount, readingTime };
}

const { novel } = Astro.props;
const { Content } = await render(novel);
const t = getTranslations();
const { characterCount, readingTime } = calculateStats(novel.body);
---

<Layout title={`${novel.data.title} - ${t.site.title}`}>
  <div
    class="max-w-prose mx-auto mb-4 flex flex-wrap gap-4 justify-end items-center text-sm"
  >
    <div class="flex items-center gap-2">
      <span class="text-gray-500">{t.novel.background}</span>
      <button
        class="w-6 h-6 rounded-full border border-gray-300 bg-white shadow-sm hover:scale-110 transition-transform cursor-pointer"
        data-theme="white"
        aria-label={t.novel.white}></button>
      <button
        class="w-6 h-6 rounded-full border border-gray-300 bg-gray-100 shadow-sm hover:scale-110 transition-transform cursor-pointer"
        data-theme="gray"
        aria-label={t.novel.gray}></button>
      <button
        class="w-6 h-6 rounded-full border border-gray-300 bg-[#fcfcda] shadow-sm hover:scale-110 transition-transform cursor-pointer"
        data-theme="yellow"
        aria-label={t.novel.yellow}></button>
      <button
        class="w-6 h-6 rounded-full border border-gray-300 bg-gray-900 shadow-sm hover:scale-110 transition-transform cursor-pointer"
        data-theme="black"
        aria-label={t.novel.black}></button>
    </div>
    <div class="flex items-center gap-2">
      <span class="text-gray-500">{t.novel.font}</span>
      <button
        class="px-2 py-1 rounded border border-gray-300 bg-white text-gray-900 font-sans shadow-sm hover:bg-gray-50 transition-colors cursor-pointer"
        data-font="sans">{t.novel.gothic}</button
      >
      <button
        class="px-2 py-1 rounded border border-gray-300 bg-white text-gray-900 font-serif shadow-sm hover:bg-gray-50 transition-colors cursor-pointer"
        data-font="serif">{t.novel.mincho}</button
      >
    </div>
    <button
      id="break-toggle"
      class="px-2 py-1 rounded border border-gray-300 bg-white text-gray-900 shadow-sm hover:bg-gray-50 transition-colors cursor-pointer text-sm"
      aria-label="折り返し設定"
    >
      折り返し
    </button>
  </div>

  <article
    id="novel-article"
    class="prose prose-base prose-headings:text-lg prose-h1:text-xl mx-auto bg-white p-4 rounded-lg shadow-sm transition-colors duration-300"
  >
    <header class="mb-8 border-b pb-4">
      <h1 class="text-3xl font-bold mb-2">{novel.data.title}</h1>
      <div class="flex flex-wrap gap-2 text-sm text-gray-600 mb-3">
        <span class="font-mono text-gray-700 bg-gray-100 px-2 py-1 rounded"
          >ID: {novel.data.id}</span
        >
        {
          novel.data.tags && novel.data.tags.length > 0 && (
            <div class="flex gap-2">
              {novel.data.tags.map((tag) => (
                <a
                  href={`/?tag=${encodeURIComponent(tag)}`}
                  class="bg-gray-100 px-2 py-1 rounded text-gray-700 hover:bg-sky-100 hover:text-sky-700 transition-colors no-underline"
                >
                  #{tag}
                </a>
              ))}
            </div>
          )
        }
      </div>
      <div class="flex flex-wrap gap-4 text-sm text-gray-500">
        <span class="flex items-center gap-1">
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"
            ></path>
          </svg>
          {characterCount.toLocaleString()}
          {t.novel.characters}
        </span>
        <span class="flex items-center gap-1">
          <svg
            class="w-4 h-4"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M12 8v4l3 2m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path>
          </svg>
          {t.novel.about}
          {readingTime}
          {t.novel.minutes}
        </span>
      </div>
    </header>
    <div class="novel-content">
      <Content />
    </div>
  </article>
</Layout>

<script>
  // Find the "あらすじ" heading and wrap it and following content in a details element
  const content = document.querySelector(".novel-content");
  if (content) {
    const headings = Array.from(content.querySelectorAll("h1, h2, h3")); // Check multiple levels just in case

    for (const heading of headings) {
      const summaryTextCandidates = ["あらすじ", "Summary", "Synopsis", "概要"];
      if (summaryTextCandidates.includes(heading.textContent?.trim() || "")) {
        const details = document.createElement("details");
        details.className =
          "mb-8 p-4 bg-gray-50 rounded-lg border border-gray-200";

        const summary = document.createElement("summary");
        summary.textContent = heading.textContent?.trim() || "あらすじ";
        summary.className =
          "cursor-pointer font-bold text-lg text-gray-800 hover:text-sky-600 transition-colors";

        details.appendChild(summary);

        // Create a container for the content
        const contentDiv = document.createElement("div");
        contentDiv.className = "mt-4 text-gray-700";
        details.appendChild(contentDiv);

        // Move siblings until the next heading of same or higher level (or hr)
        let next = heading.nextElementSibling;
        const currentLevel = parseInt(heading.tagName.substring(1));

        while (next) {
          const nextTagName = next.tagName;
          if (/^H[1-6]$/.test(nextTagName)) {
            const nextLevel = parseInt(nextTagName.substring(1));
            if (nextLevel <= currentLevel) break;
          }
          if (nextTagName === "HR") {
            // If it's an HR, we might want to stop, or include it?
            // Usually HR separates sections. Let's stop at HR and remove it or leave it outside.
            // If we leave it outside, the loop breaks.
            break;
          }

          const current = next;
          next = next.nextElementSibling;
          contentDiv.appendChild(current);
        }

        heading.replaceWith(details);
        break; // Only handle the first "あらすじ" found
      }
    }
  }

  // Theme, Font, and Break Settings
  const article = document.getElementById("novel-article");
  const novelContent = document.querySelector(".novel-content");
  const themeBtns: NodeListOf<HTMLElement> =
    document.querySelectorAll("[data-theme]");
  const fontBtns: NodeListOf<HTMLElement> =
    document.querySelectorAll("[data-font]");
  const breakToggleBtn = document.getElementById("break-toggle");

  const themes: Record<string, string[]> = {
    white: ["bg-white", "text-gray-900"],
    gray: ["bg-gray-100", "text-gray-900"],
    yellow: ["bg-[#fcfcda]", "text-gray-900"],
    black: ["bg-gray-900", "text-gray-100", "prose-invert"],
  };

  const fonts: Record<string, string[]> = {
    sans: ["font-sans"],
    serif: ["font-serif"],
  };

  const allThemeClasses = [
    "bg-white",
    "bg-gray-100",
    "bg-[#fcfcda]",
    "bg-gray-900",
    "text-gray-900",
    "text-gray-100",
    "prose-invert",
  ];
  const allFontClasses = ["font-sans", "font-serif"];

  function applyTheme(themeName?: string) {
    if (!themeName) return;
    if (!article || !themes[themeName]) return;
    article.classList.remove(...allThemeClasses);
    article.classList.add(...themes[themeName]);
    localStorage.setItem("novel-theme", themeName);

    // Update active state for buttons
    themeBtns.forEach((btn) => {
      if (btn.dataset.theme === themeName) {
        btn.classList.add("ring-2", "ring-offset-2", "ring-sky-500");
      } else {
        btn.classList.remove("ring-2", "ring-offset-2", "ring-sky-500");
      }
    });
  }

  function applyFont(fontName?: string) {
    if (!fontName) return;
    if (!article || !fonts[fontName]) return;
    article.classList.remove(...allFontClasses);
    article.classList.add(...fonts[fontName]);
    localStorage.setItem("novel-font", fontName);

    // Update active state for buttons
    fontBtns.forEach((btn) => {
      if (btn.dataset.font === fontName) {
        btn.classList.add("bg-sky-50", "border-sky-500", "text-sky-700");
        btn.classList.remove("bg-white", "border-gray-300", "text-gray-900");
      } else {
        btn.classList.remove("bg-sky-50", "border-sky-500", "text-sky-700");
        btn.classList.add("bg-white", "border-gray-300", "text-gray-900");
      }
    });
  }

  function applyBreak(breakEnabled?: boolean) {
    if (breakEnabled === undefined) return;
    if (!novelContent) return;

    if (breakEnabled) {
      novelContent.classList.add("break-auto");
    } else {
      novelContent.classList.remove("break-auto");
    }
    localStorage.setItem("novel-break", String(breakEnabled));

    // Update active state for button
    if (breakToggleBtn) {
      if (breakEnabled) {
        breakToggleBtn.classList.add(
          "bg-sky-50",
          "border-sky-500",
          "text-sky-700",
        );
        breakToggleBtn.classList.remove(
          "bg-white",
          "border-gray-300",
          "text-gray-900",
        );
      } else {
        breakToggleBtn.classList.remove(
          "bg-sky-50",
          "border-sky-500",
          "text-sky-700",
        );
        breakToggleBtn.classList.add(
          "bg-white",
          "border-gray-300",
          "text-gray-900",
        );
      }
    }
  }

  // Event Listeners
  themeBtns.forEach((btn) => {
    btn.addEventListener("click", () => applyTheme(btn.dataset.theme));
  });

  fontBtns.forEach((btn) => {
    btn.addEventListener("click", () => applyFont(btn.dataset.font));
  });

  if (breakToggleBtn) {
    breakToggleBtn.addEventListener("click", () => {
      const currentBreak =
        novelContent?.classList.contains("break-auto") ?? false;
      applyBreak(!currentBreak);
    });
  }

  // Initialize
  const savedTheme = localStorage.getItem("novel-theme") || "white";
  const savedFont = localStorage.getItem("novel-font") || "sans";
  const savedBreak = localStorage.getItem("novel-break") !== "false"; // Default to true

  applyTheme(savedTheme);
  applyFont(savedFont);
  applyBreak(savedBreak);
</script>
